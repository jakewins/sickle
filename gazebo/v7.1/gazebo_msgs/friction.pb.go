// Code generated by protoc-gen-go.
// source: friction.proto
// DO NOT EDIT!

package gazebo_msgs

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Friction struct {
	// / \brief Coefficient of friction in the range of [0..1].
	Mu *float64 `protobuf:"fixed64,1,opt,name=mu" json:"mu,omitempty"`
	// / \brief Second coefficient of friction in the range of [0..1].
	Mu2 *float64 `protobuf:"fixed64,2,opt,name=mu2" json:"mu2,omitempty"`
	// / \brief Direction of mu1 in the collision local reference frame.
	Fdir1 *Vector3D `protobuf:"bytes,3,opt,name=fdir1" json:"fdir1,omitempty"`
	// / \brief Force dependent slip direction 1 in collision local frame, between
	// / the range of [0..1].
	Slip1 *float64 `protobuf:"fixed64,4,opt,name=slip1" json:"slip1,omitempty"`
	// / \brief Force dependent slip direction 2 in collision local frame, between
	// / the range of [0..1].
	Slip2 *float64 `protobuf:"fixed64,5,opt,name=slip2" json:"slip2,omitempty"`
	// / \brief Torsional friction.
	Torsional        *Friction_Torsional `protobuf:"bytes,6,opt,name=torsional" json:"torsional,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *Friction) Reset()                    { *m = Friction{} }
func (m *Friction) String() string            { return proto.CompactTextString(m) }
func (*Friction) ProtoMessage()               {}
func (*Friction) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{0} }

func (m *Friction) GetMu() float64 {
	if m != nil && m.Mu != nil {
		return *m.Mu
	}
	return 0
}

func (m *Friction) GetMu2() float64 {
	if m != nil && m.Mu2 != nil {
		return *m.Mu2
	}
	return 0
}

func (m *Friction) GetFdir1() *Vector3D {
	if m != nil {
		return m.Fdir1
	}
	return nil
}

func (m *Friction) GetSlip1() float64 {
	if m != nil && m.Slip1 != nil {
		return *m.Slip1
	}
	return 0
}

func (m *Friction) GetSlip2() float64 {
	if m != nil && m.Slip2 != nil {
		return *m.Slip2
	}
	return 0
}

func (m *Friction) GetTorsional() *Friction_Torsional {
	if m != nil {
		return m.Torsional
	}
	return nil
}

type Friction_Torsional struct {
	// / \brief Torsional coefficient of friction in the range of [0..1].
	Coefficient *float64 `protobuf:"fixed64,1,opt,name=coefficient" json:"coefficient,omitempty"`
	// / \brief By default, torsional friction is calculated using the
	// / "patch_radius", which is sqrt(R*d), where "R" is the radius of the
	// / collision at the contact point (surface_radius) and "d" is the contact
	// / depth. If this flag is set to false, surface_radius and contact depth
	// / will be used instead of patch radius.
	UsePatchRadius *bool `protobuf:"varint,2,opt,name=use_patch_radius" json:"use_patch_radius,omitempty"`
	// / \brief Radius of contact patch surface, used for torsional friction.
	PatchRadius *float64 `protobuf:"fixed64,3,opt,name=patch_radius" json:"patch_radius,omitempty"`
	// / \brief Surface radius on the point of contact, used for torsional
	// / friction.
	SurfaceRadius *float64 `protobuf:"fixed64,4,opt,name=surface_radius" json:"surface_radius,omitempty"`
	// / \brief Torsional friction information exclusive to ODE physics engine.
	Ode              *Friction_Torsional_ODE `protobuf:"bytes,5,opt,name=ode" json:"ode,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *Friction_Torsional) Reset()                    { *m = Friction_Torsional{} }
func (m *Friction_Torsional) String() string            { return proto.CompactTextString(m) }
func (*Friction_Torsional) ProtoMessage()               {}
func (*Friction_Torsional) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{0, 0} }

func (m *Friction_Torsional) GetCoefficient() float64 {
	if m != nil && m.Coefficient != nil {
		return *m.Coefficient
	}
	return 0
}

func (m *Friction_Torsional) GetUsePatchRadius() bool {
	if m != nil && m.UsePatchRadius != nil {
		return *m.UsePatchRadius
	}
	return false
}

func (m *Friction_Torsional) GetPatchRadius() float64 {
	if m != nil && m.PatchRadius != nil {
		return *m.PatchRadius
	}
	return 0
}

func (m *Friction_Torsional) GetSurfaceRadius() float64 {
	if m != nil && m.SurfaceRadius != nil {
		return *m.SurfaceRadius
	}
	return 0
}

func (m *Friction_Torsional) GetOde() *Friction_Torsional_ODE {
	if m != nil {
		return m.Ode
	}
	return nil
}

type Friction_Torsional_ODE struct {
	// / \brief Force dependent slip for torsional friction, between the range
	// / of [0..1].
	Slip             *float64 `protobuf:"fixed64,1,opt,name=slip" json:"slip,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Friction_Torsional_ODE) Reset()                    { *m = Friction_Torsional_ODE{} }
func (m *Friction_Torsional_ODE) String() string            { return proto.CompactTextString(m) }
func (*Friction_Torsional_ODE) ProtoMessage()               {}
func (*Friction_Torsional_ODE) Descriptor() ([]byte, []int) { return fileDescriptor23, []int{0, 0, 0} }

func (m *Friction_Torsional_ODE) GetSlip() float64 {
	if m != nil && m.Slip != nil {
		return *m.Slip
	}
	return 0
}

func init() {
	proto.RegisterType((*Friction)(nil), "gazebo.msgs.Friction")
	proto.RegisterType((*Friction_Torsional)(nil), "gazebo.msgs.Friction.Torsional")
	proto.RegisterType((*Friction_Torsional_ODE)(nil), "gazebo.msgs.Friction.Torsional.ODE")
}

func init() { proto.RegisterFile("friction.proto", fileDescriptor23) }

var fileDescriptor23 = []byte{
	// 255 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x8f, 0xbd, 0x4e, 0xc3, 0x30,
	0x14, 0x85, 0x95, 0xb8, 0x41, 0xed, 0x75, 0x89, 0x90, 0x0b, 0xc8, 0xca, 0x02, 0x02, 0x06, 0x26,
	0x8b, 0x9a, 0x57, 0x00, 0x56, 0x16, 0xc4, 0x5a, 0x19, 0xc7, 0x2e, 0x96, 0x9a, 0x3a, 0xf2, 0x0f,
	0x03, 0x2f, 0xc5, 0x93, 0xf0, 0x4e, 0x04, 0x27, 0x41, 0x64, 0xea, 0x64, 0x7d, 0xd7, 0xc7, 0xc7,
	0xdf, 0x85, 0x52, 0x3b, 0x23, 0x83, 0xb1, 0x7b, 0xd6, 0x3a, 0x1b, 0x2c, 0xc1, 0x5b, 0xf1, 0xa9,
	0xde, 0x2c, 0x6b, 0xfc, 0xd6, 0x57, 0xe5, 0x87, 0x92, 0xc1, 0xba, 0xfb, 0xba, 0xbf, 0xbc, 0xfa,
	0xce, 0x61, 0xfe, 0x34, 0xe4, 0x09, 0x40, 0xde, 0x44, 0x9a, 0x5d, 0x66, 0xb7, 0x19, 0xc1, 0x80,
	0x9a, 0xc8, 0x69, 0x9e, 0xe0, 0x06, 0x0a, 0x5d, 0x1b, 0xb7, 0xa6, 0xa8, 0x43, 0xcc, 0xcf, 0xd8,
	0xbf, 0x4a, 0xf6, 0x3a, 0x34, 0x92, 0x63, 0x28, 0xfc, 0xce, 0xb4, 0x6b, 0x3a, 0x4b, 0x8f, 0x06,
	0xe4, 0xb4, 0x48, 0xc8, 0x61, 0xd1, 0xc5, 0x7c, 0xf7, 0x8f, 0xd8, 0xd1, 0xa3, 0xd4, 0x73, 0x31,
	0xe9, 0x19, 0x35, 0xd8, 0xcb, 0x18, 0xab, 0xbe, 0x32, 0x58, 0xfc, 0x11, 0x59, 0x01, 0x96, 0x56,
	0x69, 0x6d, 0xa4, 0x51, 0xfb, 0x30, 0x78, 0x52, 0x38, 0x89, 0x5e, 0x6d, 0x5a, 0x11, 0xe4, 0xfb,
	0xc6, 0x89, 0xda, 0x44, 0x9f, 0xa4, 0xe7, 0xe4, 0x14, 0x96, 0x93, 0x29, 0x4a, 0xf9, 0x73, 0x28,
	0x7d, 0x74, 0x5a, 0x48, 0x35, 0xce, 0x7b, 0xdb, 0x3b, 0x40, 0xb6, 0x56, 0xc9, 0x15, 0xf3, 0xeb,
	0x03, 0x62, 0xec, 0xf9, 0xe1, 0xb1, 0x5a, 0x01, 0xea, 0x0e, 0xb2, 0x84, 0xd9, 0xef, 0x9a, 0xbd,
	0xce, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb4, 0x0c, 0x11, 0x9a, 0x7d, 0x01, 0x00, 0x00,
}
